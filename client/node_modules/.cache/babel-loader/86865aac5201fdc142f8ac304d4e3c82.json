{"ast":null,"code":"'use strict';\n\nconst pTimeout = require('p-timeout');\n\nconst symbolAsyncIterator = Symbol.asyncIterator || '@@asyncIterator';\n\nconst normalizeEmitter = emitter => {\n  const addListener = emitter.on || emitter.addListener || emitter.addEventListener;\n  const removeListener = emitter.off || emitter.removeListener || emitter.removeEventListener;\n\n  if (!addListener || !removeListener) {\n    throw new TypeError('Emitter is not compatible');\n  }\n\n  return {\n    addListener: addListener.bind(emitter),\n    removeListener: removeListener.bind(emitter)\n  };\n};\n\nconst toArray = value => Array.isArray(value) ? value : [value];\n\nconst multiple = (emitter, event, options) => {\n  let cancel;\n  const ret = new Promise((resolve, reject) => {\n    options = {\n      rejectionEvents: ['error'],\n      multiArgs: false,\n      resolveImmediately: false,\n      ...options\n    };\n\n    if (!(options.count >= 0 && (options.count === Infinity || Number.isInteger(options.count)))) {\n      throw new TypeError('The `count` option should be at least 0 or more');\n    } // Allow multiple events\n\n\n    const events = toArray(event);\n    const items = [];\n    const {\n      addListener,\n      removeListener\n    } = normalizeEmitter(emitter);\n\n    const onItem = (...args) => {\n      const value = options.multiArgs ? args : args[0];\n\n      if (options.filter && !options.filter(value)) {\n        return;\n      }\n\n      items.push(value);\n\n      if (options.count === items.length) {\n        cancel();\n        resolve(items);\n      }\n    };\n\n    const rejectHandler = error => {\n      cancel();\n      reject(error);\n    };\n\n    cancel = () => {\n      for (const event of events) {\n        removeListener(event, onItem);\n      }\n\n      for (const rejectionEvent of options.rejectionEvents) {\n        removeListener(rejectionEvent, rejectHandler);\n      }\n    };\n\n    for (const event of events) {\n      addListener(event, onItem);\n    }\n\n    for (const rejectionEvent of options.rejectionEvents) {\n      addListener(rejectionEvent, rejectHandler);\n    }\n\n    if (options.resolveImmediately) {\n      resolve(items);\n    }\n  });\n  ret.cancel = cancel;\n\n  if (typeof options.timeout === 'number') {\n    const timeout = pTimeout(ret, options.timeout);\n    timeout.cancel = cancel;\n    return timeout;\n  }\n\n  return ret;\n};\n\nconst pEvent = (emitter, event, options) => {\n  if (typeof options === 'function') {\n    options = {\n      filter: options\n    };\n  }\n\n  options = { ...options,\n    count: 1,\n    resolveImmediately: false\n  };\n  const arrayPromise = multiple(emitter, event, options);\n  const promise = arrayPromise.then(array => array[0]); // eslint-disable-line promise/prefer-await-to-then\n\n  promise.cancel = arrayPromise.cancel;\n  return promise;\n};\n\nmodule.exports = pEvent; // TODO: Remove this for the next major release\n\nmodule.exports.default = pEvent;\nmodule.exports.multiple = multiple;\n\nmodule.exports.iterator = (emitter, event, options) => {\n  if (typeof options === 'function') {\n    options = {\n      filter: options\n    };\n  } // Allow multiple events\n\n\n  const events = toArray(event);\n  options = {\n    rejectionEvents: ['error'],\n    resolutionEvents: [],\n    limit: Infinity,\n    multiArgs: false,\n    ...options\n  };\n  const {\n    limit\n  } = options;\n  const isValidLimit = limit >= 0 && (limit === Infinity || Number.isInteger(limit));\n\n  if (!isValidLimit) {\n    throw new TypeError('The `limit` option should be a non-negative integer or Infinity');\n  }\n\n  if (limit === 0) {\n    // Return an empty async iterator to avoid any further cost\n    return {\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n\n      async next() {\n        return {\n          done: true,\n          value: undefined\n        };\n      }\n\n    };\n  }\n\n  const {\n    addListener,\n    removeListener\n  } = normalizeEmitter(emitter);\n  let isDone = false;\n  let error;\n  let hasPendingError = false;\n  const nextQueue = [];\n  const valueQueue = [];\n  let eventCount = 0;\n  let isLimitReached = false;\n\n  const valueHandler = (...args) => {\n    eventCount++;\n    isLimitReached = eventCount === limit;\n    const value = options.multiArgs ? args : args[0];\n\n    if (nextQueue.length > 0) {\n      const {\n        resolve\n      } = nextQueue.shift();\n      resolve({\n        done: false,\n        value\n      });\n\n      if (isLimitReached) {\n        cancel();\n      }\n\n      return;\n    }\n\n    valueQueue.push(value);\n\n    if (isLimitReached) {\n      cancel();\n    }\n  };\n\n  const cancel = () => {\n    isDone = true;\n\n    for (const event of events) {\n      removeListener(event, valueHandler);\n    }\n\n    for (const rejectionEvent of options.rejectionEvents) {\n      removeListener(rejectionEvent, rejectHandler);\n    }\n\n    for (const resolutionEvent of options.resolutionEvents) {\n      removeListener(resolutionEvent, resolveHandler);\n    }\n\n    while (nextQueue.length > 0) {\n      const {\n        resolve\n      } = nextQueue.shift();\n      resolve({\n        done: true,\n        value: undefined\n      });\n    }\n  };\n\n  const rejectHandler = (...args) => {\n    error = options.multiArgs ? args : args[0];\n\n    if (nextQueue.length > 0) {\n      const {\n        reject\n      } = nextQueue.shift();\n      reject(error);\n    } else {\n      hasPendingError = true;\n    }\n\n    cancel();\n  };\n\n  const resolveHandler = (...args) => {\n    const value = options.multiArgs ? args : args[0];\n\n    if (options.filter && !options.filter(value)) {\n      return;\n    }\n\n    if (nextQueue.length > 0) {\n      const {\n        resolve\n      } = nextQueue.shift();\n      resolve({\n        done: true,\n        value\n      });\n    } else {\n      valueQueue.push(value);\n    }\n\n    cancel();\n  };\n\n  for (const event of events) {\n    addListener(event, valueHandler);\n  }\n\n  for (const rejectionEvent of options.rejectionEvents) {\n    addListener(rejectionEvent, rejectHandler);\n  }\n\n  for (const resolutionEvent of options.resolutionEvents) {\n    addListener(resolutionEvent, resolveHandler);\n  }\n\n  return {\n    [symbolAsyncIterator]() {\n      return this;\n    },\n\n    async next() {\n      if (valueQueue.length > 0) {\n        const value = valueQueue.shift();\n        return {\n          done: isDone && valueQueue.length === 0 && !isLimitReached,\n          value\n        };\n      }\n\n      if (hasPendingError) {\n        hasPendingError = false;\n        throw error;\n      }\n\n      if (isDone) {\n        return {\n          done: true,\n          value: undefined\n        };\n      }\n\n      return new Promise((resolve, reject) => nextQueue.push({\n        resolve,\n        reject\n      }));\n    },\n\n    async return(value) {\n      cancel();\n      return {\n        done: isDone,\n        value\n      };\n    }\n\n  };\n};\n\nmodule.exports.TimeoutError = pTimeout.TimeoutError;","map":{"version":3,"sources":["D:/Documents/GitHub/karaoke/client/node_modules/p-event/index.js"],"names":["pTimeout","require","symbolAsyncIterator","Symbol","asyncIterator","normalizeEmitter","emitter","addListener","on","addEventListener","removeListener","off","removeEventListener","TypeError","bind","toArray","value","Array","isArray","multiple","event","options","cancel","ret","Promise","resolve","reject","rejectionEvents","multiArgs","resolveImmediately","count","Infinity","Number","isInteger","events","items","onItem","args","filter","push","length","rejectHandler","error","rejectionEvent","timeout","pEvent","arrayPromise","promise","then","array","module","exports","default","iterator","resolutionEvents","limit","isValidLimit","next","done","undefined","isDone","hasPendingError","nextQueue","valueQueue","eventCount","isLimitReached","valueHandler","shift","resolutionEvent","resolveHandler","return","TimeoutError"],"mappings":"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","sourcesContent":["'use strict';\nconst pTimeout = require('p-timeout');\n\nconst symbolAsyncIterator = Symbol.asyncIterator || '@@asyncIterator';\n\nconst normalizeEmitter = emitter => {\n\tconst addListener = emitter.on || emitter.addListener || emitter.addEventListener;\n\tconst removeListener = emitter.off || emitter.removeListener || emitter.removeEventListener;\n\n\tif (!addListener || !removeListener) {\n\t\tthrow new TypeError('Emitter is not compatible');\n\t}\n\n\treturn {\n\t\taddListener: addListener.bind(emitter),\n\t\tremoveListener: removeListener.bind(emitter)\n\t};\n};\n\nconst toArray = value => Array.isArray(value) ? value : [value];\n\nconst multiple = (emitter, event, options) => {\n\tlet cancel;\n\tconst ret = new Promise((resolve, reject) => {\n\t\toptions = {\n\t\t\trejectionEvents: ['error'],\n\t\t\tmultiArgs: false,\n\t\t\tresolveImmediately: false,\n\t\t\t...options\n\t\t};\n\n\t\tif (!(options.count >= 0 && (options.count === Infinity || Number.isInteger(options.count)))) {\n\t\t\tthrow new TypeError('The `count` option should be at least 0 or more');\n\t\t}\n\n\t\t// Allow multiple events\n\t\tconst events = toArray(event);\n\n\t\tconst items = [];\n\t\tconst {addListener, removeListener} = normalizeEmitter(emitter);\n\n\t\tconst onItem = (...args) => {\n\t\t\tconst value = options.multiArgs ? args : args[0];\n\n\t\t\tif (options.filter && !options.filter(value)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\titems.push(value);\n\n\t\t\tif (options.count === items.length) {\n\t\t\t\tcancel();\n\t\t\t\tresolve(items);\n\t\t\t}\n\t\t};\n\n\t\tconst rejectHandler = error => {\n\t\t\tcancel();\n\t\t\treject(error);\n\t\t};\n\n\t\tcancel = () => {\n\t\t\tfor (const event of events) {\n\t\t\t\tremoveListener(event, onItem);\n\t\t\t}\n\n\t\t\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\t\t\tremoveListener(rejectionEvent, rejectHandler);\n\t\t\t}\n\t\t};\n\n\t\tfor (const event of events) {\n\t\t\taddListener(event, onItem);\n\t\t}\n\n\t\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\t\taddListener(rejectionEvent, rejectHandler);\n\t\t}\n\n\t\tif (options.resolveImmediately) {\n\t\t\tresolve(items);\n\t\t}\n\t});\n\n\tret.cancel = cancel;\n\n\tif (typeof options.timeout === 'number') {\n\t\tconst timeout = pTimeout(ret, options.timeout);\n\t\ttimeout.cancel = cancel;\n\t\treturn timeout;\n\t}\n\n\treturn ret;\n};\n\nconst pEvent = (emitter, event, options) => {\n\tif (typeof options === 'function') {\n\t\toptions = {filter: options};\n\t}\n\n\toptions = {\n\t\t...options,\n\t\tcount: 1,\n\t\tresolveImmediately: false\n\t};\n\n\tconst arrayPromise = multiple(emitter, event, options);\n\tconst promise = arrayPromise.then(array => array[0]); // eslint-disable-line promise/prefer-await-to-then\n\tpromise.cancel = arrayPromise.cancel;\n\n\treturn promise;\n};\n\nmodule.exports = pEvent;\n// TODO: Remove this for the next major release\nmodule.exports.default = pEvent;\n\nmodule.exports.multiple = multiple;\n\nmodule.exports.iterator = (emitter, event, options) => {\n\tif (typeof options === 'function') {\n\t\toptions = {filter: options};\n\t}\n\n\t// Allow multiple events\n\tconst events = toArray(event);\n\n\toptions = {\n\t\trejectionEvents: ['error'],\n\t\tresolutionEvents: [],\n\t\tlimit: Infinity,\n\t\tmultiArgs: false,\n\t\t...options\n\t};\n\n\tconst {limit} = options;\n\tconst isValidLimit = limit >= 0 && (limit === Infinity || Number.isInteger(limit));\n\tif (!isValidLimit) {\n\t\tthrow new TypeError('The `limit` option should be a non-negative integer or Infinity');\n\t}\n\n\tif (limit === 0) {\n\t\t// Return an empty async iterator to avoid any further cost\n\t\treturn {\n\t\t\t[Symbol.asyncIterator]() {\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tasync next() {\n\t\t\t\treturn {\n\t\t\t\t\tdone: true,\n\t\t\t\t\tvalue: undefined\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t}\n\n\tconst {addListener, removeListener} = normalizeEmitter(emitter);\n\n\tlet isDone = false;\n\tlet error;\n\tlet hasPendingError = false;\n\tconst nextQueue = [];\n\tconst valueQueue = [];\n\tlet eventCount = 0;\n\tlet isLimitReached = false;\n\n\tconst valueHandler = (...args) => {\n\t\teventCount++;\n\t\tisLimitReached = eventCount === limit;\n\n\t\tconst value = options.multiArgs ? args : args[0];\n\n\t\tif (nextQueue.length > 0) {\n\t\t\tconst {resolve} = nextQueue.shift();\n\n\t\t\tresolve({done: false, value});\n\n\t\t\tif (isLimitReached) {\n\t\t\t\tcancel();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tvalueQueue.push(value);\n\n\t\tif (isLimitReached) {\n\t\t\tcancel();\n\t\t}\n\t};\n\n\tconst cancel = () => {\n\t\tisDone = true;\n\t\tfor (const event of events) {\n\t\t\tremoveListener(event, valueHandler);\n\t\t}\n\n\t\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\t\tremoveListener(rejectionEvent, rejectHandler);\n\t\t}\n\n\t\tfor (const resolutionEvent of options.resolutionEvents) {\n\t\t\tremoveListener(resolutionEvent, resolveHandler);\n\t\t}\n\n\t\twhile (nextQueue.length > 0) {\n\t\t\tconst {resolve} = nextQueue.shift();\n\t\t\tresolve({done: true, value: undefined});\n\t\t}\n\t};\n\n\tconst rejectHandler = (...args) => {\n\t\terror = options.multiArgs ? args : args[0];\n\n\t\tif (nextQueue.length > 0) {\n\t\t\tconst {reject} = nextQueue.shift();\n\t\t\treject(error);\n\t\t} else {\n\t\t\thasPendingError = true;\n\t\t}\n\n\t\tcancel();\n\t};\n\n\tconst resolveHandler = (...args) => {\n\t\tconst value = options.multiArgs ? args : args[0];\n\n\t\tif (options.filter && !options.filter(value)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (nextQueue.length > 0) {\n\t\t\tconst {resolve} = nextQueue.shift();\n\t\t\tresolve({done: true, value});\n\t\t} else {\n\t\t\tvalueQueue.push(value);\n\t\t}\n\n\t\tcancel();\n\t};\n\n\tfor (const event of events) {\n\t\taddListener(event, valueHandler);\n\t}\n\n\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\taddListener(rejectionEvent, rejectHandler);\n\t}\n\n\tfor (const resolutionEvent of options.resolutionEvents) {\n\t\taddListener(resolutionEvent, resolveHandler);\n\t}\n\n\treturn {\n\t\t[symbolAsyncIterator]() {\n\t\t\treturn this;\n\t\t},\n\t\tasync next() {\n\t\t\tif (valueQueue.length > 0) {\n\t\t\t\tconst value = valueQueue.shift();\n\t\t\t\treturn {\n\t\t\t\t\tdone: isDone && valueQueue.length === 0 && !isLimitReached,\n\t\t\t\t\tvalue\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (hasPendingError) {\n\t\t\t\thasPendingError = false;\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tif (isDone) {\n\t\t\t\treturn {\n\t\t\t\t\tdone: true,\n\t\t\t\t\tvalue: undefined\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => nextQueue.push({resolve, reject}));\n\t\t},\n\t\tasync return(value) {\n\t\t\tcancel();\n\t\t\treturn {\n\t\t\t\tdone: isDone,\n\t\t\t\tvalue\n\t\t\t};\n\t\t}\n\t};\n};\n\nmodule.exports.TimeoutError = pTimeout.TimeoutError;\n"]},"metadata":{},"sourceType":"script"}