{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport removeAccents from 'remove-accents';\nvar rankings = {\n  CASE_SENSITIVE_EQUAL: 7,\n  EQUAL: 6,\n  STARTS_WITH: 5,\n  WORD_STARTS_WITH: 4,\n  CONTAINS: 3,\n  ACRONYM: 2,\n  MATCHES: 1,\n  NO_MATCH: 0\n};\nmatchSorter.rankings = rankings;\n\nvar defaultBaseSortFn = function (a, b) {\n  return String(a.rankedValue).localeCompare(String(b.rankedValue));\n};\n/**\n * Takes an array of items and a value and returns a new array with the items that match the given value\n * @param {Array} items - the items to sort\n * @param {String} value - the value to use for ranking\n * @param {Object} options - Some options to configure the sorter\n * @return {Array} - the new sorted array\n */\n\n\nfunction matchSorter(items, value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      keys = _options.keys,\n      _options$threshold = _options.threshold,\n      threshold = _options$threshold === void 0 ? rankings.MATCHES : _options$threshold,\n      _options$baseSort = _options.baseSort,\n      baseSort = _options$baseSort === void 0 ? defaultBaseSortFn : _options$baseSort;\n  var matchedItems = items.reduce(reduceItemsToRanked, []);\n  return matchedItems.sort(function (a, b) {\n    return sortRankedValues(a, b, baseSort);\n  }).map(function (_ref) {\n    var item = _ref.item;\n    return item;\n  });\n\n  function reduceItemsToRanked(matches, item, index) {\n    var rankingInfo = getHighestRanking(item, keys, value, options);\n    var rank = rankingInfo.rank,\n        _rankingInfo$keyThres = rankingInfo.keyThreshold,\n        keyThreshold = _rankingInfo$keyThres === void 0 ? threshold : _rankingInfo$keyThres;\n\n    if (rank >= keyThreshold) {\n      matches.push(_extends({}, rankingInfo, {\n        item: item,\n        index: index\n      }));\n    }\n\n    return matches;\n  }\n}\n/**\n * Gets the highest ranking for value for the given item based on its values for the given keys\n * @param {*} item - the item to rank\n * @param {Array} keys - the keys to get values from the item for the ranking\n * @param {String} value - the value to rank against\n * @param {Object} options - options to control the ranking\n * @return {{rank: Number, keyIndex: Number, keyThreshold: Number}} - the highest ranking\n */\n\n\nfunction getHighestRanking(item, keys, value, options) {\n  if (!keys) {\n    // if keys is not specified, then we assume the item given is ready to be matched\n    var stringItem = item;\n    return {\n      // ends up being duplicate of 'item' in matches but consistent\n      rankedValue: stringItem,\n      rank: getMatchRanking(stringItem, value, options),\n      keyIndex: -1,\n      keyThreshold: options.threshold\n    };\n  }\n\n  var valuesToRank = getAllValuesToRank(item, keys);\n  return valuesToRank.reduce(function (_ref2, _ref3, i) {\n    var rank = _ref2.rank,\n        rankedValue = _ref2.rankedValue,\n        keyIndex = _ref2.keyIndex,\n        keyThreshold = _ref2.keyThreshold;\n    var itemValue = _ref3.itemValue,\n        attributes = _ref3.attributes;\n    var newRank = getMatchRanking(itemValue, value, options);\n    var newRankedValue = rankedValue;\n    var minRanking = attributes.minRanking,\n        maxRanking = attributes.maxRanking,\n        threshold = attributes.threshold;\n\n    if (newRank < minRanking && newRank >= rankings.MATCHES) {\n      newRank = minRanking;\n    } else if (newRank > maxRanking) {\n      newRank = maxRanking;\n    }\n\n    if (newRank > rank) {\n      rank = newRank;\n      keyIndex = i;\n      keyThreshold = threshold;\n      newRankedValue = itemValue;\n    }\n\n    return {\n      rankedValue: newRankedValue,\n      rank: rank,\n      keyIndex: keyIndex,\n      keyThreshold: keyThreshold\n    };\n  }, {\n    rankedValue: item,\n    rank: rankings.NO_MATCH,\n    keyIndex: -1,\n    keyThreshold: options.threshold\n  });\n}\n/**\n * Gives a rankings score based on how well the two strings match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @param {Object} options - options for the match (like keepDiacritics for comparison)\n * @returns {Number} the ranking for how well stringToRank matches testString\n */\n\n\nfunction getMatchRanking(testString, stringToRank, options) {\n  testString = prepareValueForComparison(testString, options);\n  stringToRank = prepareValueForComparison(stringToRank, options); // too long\n\n  if (stringToRank.length > testString.length) {\n    return rankings.NO_MATCH;\n  } // case sensitive equals\n\n\n  if (testString === stringToRank) {\n    return rankings.CASE_SENSITIVE_EQUAL;\n  } // Lower casing before further comparison\n\n\n  testString = testString.toLowerCase();\n  stringToRank = stringToRank.toLowerCase(); // case insensitive equals\n\n  if (testString === stringToRank) {\n    return rankings.EQUAL;\n  } // starts with\n\n\n  if (testString.startsWith(stringToRank)) {\n    return rankings.STARTS_WITH;\n  } // word starts with\n\n\n  if (testString.includes(\" \" + stringToRank)) {\n    return rankings.WORD_STARTS_WITH;\n  } // contains\n\n\n  if (testString.includes(stringToRank)) {\n    return rankings.CONTAINS;\n  } else if (stringToRank.length === 1) {\n    // If the only character in the given stringToRank\n    //   isn't even contained in the testString, then\n    //   it's definitely not a match.\n    return rankings.NO_MATCH;\n  } // acronym\n\n\n  if (getAcronym(testString).includes(stringToRank)) {\n    return rankings.ACRONYM;\n  } // will return a number between rankings.MATCHES and\n  // rankings.MATCHES + 1 depending  on how close of a match it is.\n\n\n  return getClosenessRanking(testString, stringToRank);\n}\n/**\n * Generates an acronym for a string.\n *\n * @param {String} string the string for which to produce the acronym\n * @returns {String} the acronym\n */\n\n\nfunction getAcronym(string) {\n  var acronym = '';\n  var wordsInString = string.split(' ');\n  wordsInString.forEach(function (wordInString) {\n    var splitByHyphenWords = wordInString.split('-');\n    splitByHyphenWords.forEach(function (splitByHyphenWord) {\n      acronym += splitByHyphenWord.substr(0, 1);\n    });\n  });\n  return acronym;\n}\n/**\n * Returns a score based on how spread apart the\n * characters from the stringToRank are within the testString.\n * A number close to rankings.MATCHES represents a loose match. A number close\n * to rankings.MATCHES + 1 represents a tighter match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @returns {Number} the number between rankings.MATCHES and\n * rankings.MATCHES + 1 for how well stringToRank matches testString\n */\n\n\nfunction getClosenessRanking(testString, stringToRank) {\n  var matchingInOrderCharCount = 0;\n  var charNumber = 0;\n\n  function findMatchingCharacter(matchChar, string, index) {\n    for (var j = index, J = string.length; j < J; j++) {\n      var stringChar = string[j];\n\n      if (stringChar === matchChar) {\n        matchingInOrderCharCount += 1;\n        return j + 1;\n      }\n    }\n\n    return -1;\n  }\n\n  function getRanking(spread) {\n    var inOrderPercentage = matchingInOrderCharCount / stringToRank.length;\n    var ranking = rankings.MATCHES + inOrderPercentage * (1 / spread);\n    return ranking;\n  }\n\n  var firstIndex = findMatchingCharacter(stringToRank[0], testString, 0);\n\n  if (firstIndex < 0) {\n    return rankings.NO_MATCH;\n  }\n\n  charNumber = firstIndex;\n\n  for (var i = 1, I = stringToRank.length; i < I; i++) {\n    var matchChar = stringToRank[i];\n    charNumber = findMatchingCharacter(matchChar, testString, charNumber);\n    var found = charNumber > -1;\n\n    if (!found) {\n      return rankings.NO_MATCH;\n    }\n  }\n\n  var spread = charNumber - firstIndex;\n  return getRanking(spread);\n}\n/**\n * Sorts items that have a rank, index, and keyIndex\n * @param {Object} a - the first item to sort\n * @param {Object} b - the second item to sort\n * @return {Number} -1 if a should come first, 1 if b should come first, 0 if equal\n */\n\n\nfunction sortRankedValues(a, b, baseSort) {\n  var aFirst = -1;\n  var bFirst = 1;\n  var aRank = a.rank,\n      aKeyIndex = a.keyIndex;\n  var bRank = b.rank,\n      bKeyIndex = b.keyIndex;\n\n  if (aRank === bRank) {\n    if (aKeyIndex === bKeyIndex) {\n      // use the base sort function as a tie-breaker\n      return baseSort(a, b);\n    } else {\n      return aKeyIndex < bKeyIndex ? aFirst : bFirst;\n    }\n  } else {\n    return aRank > bRank ? aFirst : bFirst;\n  }\n}\n/**\n * Prepares value for comparison by stringifying it, removing diacritics (if specified)\n * @param {String} value - the value to clean\n * @param {Object} options - {keepDiacritics: whether to remove diacritics}\n * @return {String} the prepared value\n */\n\n\nfunction prepareValueForComparison(value, _ref4) {\n  var keepDiacritics = _ref4.keepDiacritics; // value might not actually be a string at this point (we don't get to choose)\n  // so part of preparing the value for comparison is ensure that it is a string\n\n  value = \"\" + value; // toString\n\n  if (!keepDiacritics) {\n    value = removeAccents(value);\n  }\n\n  return value;\n}\n/**\n * Gets value for key in item at arbitrarily nested keypath\n * @param {Object} item - the item\n * @param {Object|Function} key - the potentially nested keypath or property callback\n * @return {Array} - an array containing the value(s) at the nested keypath\n */\n\n\nfunction getItemValues(item, key) {\n  if (typeof key === 'object') {\n    key = key.key;\n  }\n\n  var value;\n\n  if (typeof key === 'function') {\n    value = key(item);\n  } else if (item == null) {\n    value = null;\n  } else if (Object.hasOwnProperty.call(item, key)) {\n    value = item[key];\n  } else if (key.includes('.')) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    return getNestedValues(key, item);\n  } else {\n    value = null;\n  } // because `value` can also be undefined\n\n\n  if (value == null) {\n    return [];\n  }\n\n  if (Array.isArray(value)) {\n    return value;\n  }\n\n  return [String(value)];\n}\n/**\n * Given path: \"foo.bar.baz\"\n * And item: {foo: {bar: {baz: 'buzz'}}}\n *   -> 'buzz'\n * @param path a dot-separated set of keys\n * @param item the item to get the value from\n */\n\n\nfunction getNestedValues(path, item) {\n  var keys = path.split('.');\n  var values = [item];\n\n  for (var i = 0, I = keys.length; i < I; i++) {\n    var nestedKey = keys[i];\n    var nestedValues = [];\n\n    for (var j = 0, J = values.length; j < J; j++) {\n      var nestedItem = values[j];\n      if (nestedItem == null) continue;\n\n      if (Object.hasOwnProperty.call(nestedItem, nestedKey)) {\n        var nestedValue = nestedItem[nestedKey];\n\n        if (nestedValue != null) {\n          nestedValues.push(nestedValue);\n        }\n      } else if (nestedKey === '*') {\n        // ensure that values is an array\n        nestedValues = nestedValues.concat(nestedItem);\n      }\n    }\n\n    values = nestedValues;\n  }\n\n  if (Array.isArray(values[0])) {\n    // keep allowing the implicit wildcard for an array of strings at the end of\n    // the path; don't use `.flat()` because that's not available in node.js v10\n    var result = [];\n    return result.concat.apply(result, values);\n  } // Based on our logic it should be an array of strings by now...\n  // assuming the user's path terminated in strings\n\n\n  return values;\n}\n/**\n * Gets all the values for the given keys in the given item and returns an array of those values\n * @param item - the item from which the values will be retrieved\n * @param keys - the keys to use to retrieve the values\n * @return objects with {itemValue, attributes}\n */\n\n\nfunction getAllValuesToRank(item, keys) {\n  var allValues = [];\n\n  for (var j = 0, J = keys.length; j < J; j++) {\n    var key = keys[j];\n    var attributes = getKeyAttributes(key);\n    var itemValues = getItemValues(item, key);\n\n    for (var i = 0, I = itemValues.length; i < I; i++) {\n      allValues.push({\n        itemValue: itemValues[i],\n        attributes: attributes\n      });\n    }\n  }\n\n  return allValues;\n}\n\nvar defaultKeyAttributes = {\n  maxRanking: Infinity,\n  minRanking: -Infinity\n};\n/**\n * Gets all the attributes for the given key\n * @param key - the key from which the attributes will be retrieved\n * @return object containing the key's attributes\n */\n\nfunction getKeyAttributes(key) {\n  if (typeof key === 'string') {\n    return defaultKeyAttributes;\n  }\n\n  return _extends({}, defaultKeyAttributes, key);\n}\n/*\neslint\n  no-continue: \"off\",\n*/\n\n\nexport { defaultBaseSortFn, matchSorter, rankings };","map":{"version":3,"sources":["D:/Documents/GitHub/karaoke/client/node_modules/match-sorter/dist/match-sorter.esm.js"],"names":["_extends","removeAccents","rankings","CASE_SENSITIVE_EQUAL","EQUAL","STARTS_WITH","WORD_STARTS_WITH","CONTAINS","ACRONYM","MATCHES","NO_MATCH","matchSorter","defaultBaseSortFn","a","b","String","rankedValue","localeCompare","items","value","options","_options","keys","_options$threshold","threshold","_options$baseSort","baseSort","matchedItems","reduce","reduceItemsToRanked","sort","sortRankedValues","map","_ref","item","matches","index","rankingInfo","getHighestRanking","rank","_rankingInfo$keyThres","keyThreshold","push","stringItem","getMatchRanking","keyIndex","valuesToRank","getAllValuesToRank","_ref2","_ref3","i","itemValue","attributes","newRank","newRankedValue","minRanking","maxRanking","testString","stringToRank","prepareValueForComparison","length","toLowerCase","startsWith","includes","getAcronym","getClosenessRanking","string","acronym","wordsInString","split","forEach","wordInString","splitByHyphenWords","splitByHyphenWord","substr","matchingInOrderCharCount","charNumber","findMatchingCharacter","matchChar","j","J","stringChar","getRanking","spread","inOrderPercentage","ranking","firstIndex","I","found","aFirst","bFirst","aRank","aKeyIndex","bRank","bKeyIndex","_ref4","keepDiacritics","getItemValues","key","Object","hasOwnProperty","call","getNestedValues","Array","isArray","path","values","nestedKey","nestedValues","nestedItem","nestedValue","concat","result","apply","allValues","getKeyAttributes","itemValues","defaultKeyAttributes","Infinity"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,oCAArB;AACA,OAAOC,aAAP,MAA0B,gBAA1B;AAEA,IAAIC,QAAQ,GAAG;AACbC,EAAAA,oBAAoB,EAAE,CADT;AAEbC,EAAAA,KAAK,EAAE,CAFM;AAGbC,EAAAA,WAAW,EAAE,CAHA;AAIbC,EAAAA,gBAAgB,EAAE,CAJL;AAKbC,EAAAA,QAAQ,EAAE,CALG;AAMbC,EAAAA,OAAO,EAAE,CANI;AAObC,EAAAA,OAAO,EAAE,CAPI;AAQbC,EAAAA,QAAQ,EAAE;AARG,CAAf;AAUAC,WAAW,CAACT,QAAZ,GAAuBA,QAAvB;;AAEA,IAAIU,iBAAiB,GAAG,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AACtC,SAAOC,MAAM,CAACF,CAAC,CAACG,WAAH,CAAN,CAAsBC,aAAtB,CAAoCF,MAAM,CAACD,CAAC,CAACE,WAAH,CAA1C,CAAP;AACD,CAFD;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASL,WAAT,CAAqBO,KAArB,EAA4BC,KAA5B,EAAmCC,OAAnC,EAA4C;AAC1C,MAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;AACtBA,IAAAA,OAAO,GAAG,EAAV;AACD;;AAED,MAAIC,QAAQ,GAAGD,OAAf;AAAA,MACIE,IAAI,GAAGD,QAAQ,CAACC,IADpB;AAAA,MAEIC,kBAAkB,GAAGF,QAAQ,CAACG,SAFlC;AAAA,MAGIA,SAAS,GAAGD,kBAAkB,KAAK,KAAK,CAA5B,GAAgCrB,QAAQ,CAACO,OAAzC,GAAmDc,kBAHnE;AAAA,MAIIE,iBAAiB,GAAGJ,QAAQ,CAACK,QAJjC;AAAA,MAKIA,QAAQ,GAAGD,iBAAiB,KAAK,KAAK,CAA3B,GAA+Bb,iBAA/B,GAAmDa,iBALlE;AAMA,MAAIE,YAAY,GAAGT,KAAK,CAACU,MAAN,CAAaC,mBAAb,EAAkC,EAAlC,CAAnB;AACA,SAAOF,YAAY,CAACG,IAAb,CAAkB,UAAUjB,CAAV,EAAaC,CAAb,EAAgB;AACvC,WAAOiB,gBAAgB,CAAClB,CAAD,EAAIC,CAAJ,EAAOY,QAAP,CAAvB;AACD,GAFM,EAEJM,GAFI,CAEA,UAAUC,IAAV,EAAgB;AACrB,QAAIC,IAAI,GAAGD,IAAI,CAACC,IAAhB;AACA,WAAOA,IAAP;AACD,GALM,CAAP;;AAOA,WAASL,mBAAT,CAA6BM,OAA7B,EAAsCD,IAAtC,EAA4CE,KAA5C,EAAmD;AACjD,QAAIC,WAAW,GAAGC,iBAAiB,CAACJ,IAAD,EAAOZ,IAAP,EAAaH,KAAb,EAAoBC,OAApB,CAAnC;AACA,QAAImB,IAAI,GAAGF,WAAW,CAACE,IAAvB;AAAA,QACIC,qBAAqB,GAAGH,WAAW,CAACI,YADxC;AAAA,QAEIA,YAAY,GAAGD,qBAAqB,KAAK,KAAK,CAA/B,GAAmChB,SAAnC,GAA+CgB,qBAFlE;;AAIA,QAAID,IAAI,IAAIE,YAAZ,EAA0B;AACxBN,MAAAA,OAAO,CAACO,IAAR,CAAa1C,QAAQ,CAAC,EAAD,EAAKqC,WAAL,EAAkB;AACrCH,QAAAA,IAAI,EAAEA,IAD+B;AAErCE,QAAAA,KAAK,EAAEA;AAF8B,OAAlB,CAArB;AAID;;AAED,WAAOD,OAAP;AACD;AACF;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASG,iBAAT,CAA2BJ,IAA3B,EAAiCZ,IAAjC,EAAuCH,KAAvC,EAA8CC,OAA9C,EAAuD;AACrD,MAAI,CAACE,IAAL,EAAW;AACT;AACA,QAAIqB,UAAU,GAAGT,IAAjB;AACA,WAAO;AACL;AACAlB,MAAAA,WAAW,EAAE2B,UAFR;AAGLJ,MAAAA,IAAI,EAAEK,eAAe,CAACD,UAAD,EAAaxB,KAAb,EAAoBC,OAApB,CAHhB;AAILyB,MAAAA,QAAQ,EAAE,CAAC,CAJN;AAKLJ,MAAAA,YAAY,EAAErB,OAAO,CAACI;AALjB,KAAP;AAOD;;AAED,MAAIsB,YAAY,GAAGC,kBAAkB,CAACb,IAAD,EAAOZ,IAAP,CAArC;AACA,SAAOwB,YAAY,CAAClB,MAAb,CAAoB,UAAUoB,KAAV,EAAiBC,KAAjB,EAAwBC,CAAxB,EAA2B;AACpD,QAAIX,IAAI,GAAGS,KAAK,CAACT,IAAjB;AAAA,QACIvB,WAAW,GAAGgC,KAAK,CAAChC,WADxB;AAAA,QAEI6B,QAAQ,GAAGG,KAAK,CAACH,QAFrB;AAAA,QAGIJ,YAAY,GAAGO,KAAK,CAACP,YAHzB;AAIA,QAAIU,SAAS,GAAGF,KAAK,CAACE,SAAtB;AAAA,QACIC,UAAU,GAAGH,KAAK,CAACG,UADvB;AAEA,QAAIC,OAAO,GAAGT,eAAe,CAACO,SAAD,EAAYhC,KAAZ,EAAmBC,OAAnB,CAA7B;AACA,QAAIkC,cAAc,GAAGtC,WAArB;AACA,QAAIuC,UAAU,GAAGH,UAAU,CAACG,UAA5B;AAAA,QACIC,UAAU,GAAGJ,UAAU,CAACI,UAD5B;AAAA,QAEIhC,SAAS,GAAG4B,UAAU,CAAC5B,SAF3B;;AAIA,QAAI6B,OAAO,GAAGE,UAAV,IAAwBF,OAAO,IAAInD,QAAQ,CAACO,OAAhD,EAAyD;AACvD4C,MAAAA,OAAO,GAAGE,UAAV;AACD,KAFD,MAEO,IAAIF,OAAO,GAAGG,UAAd,EAA0B;AAC/BH,MAAAA,OAAO,GAAGG,UAAV;AACD;;AAED,QAAIH,OAAO,GAAGd,IAAd,EAAoB;AAClBA,MAAAA,IAAI,GAAGc,OAAP;AACAR,MAAAA,QAAQ,GAAGK,CAAX;AACAT,MAAAA,YAAY,GAAGjB,SAAf;AACA8B,MAAAA,cAAc,GAAGH,SAAjB;AACD;;AAED,WAAO;AACLnC,MAAAA,WAAW,EAAEsC,cADR;AAELf,MAAAA,IAAI,EAAEA,IAFD;AAGLM,MAAAA,QAAQ,EAAEA,QAHL;AAILJ,MAAAA,YAAY,EAAEA;AAJT,KAAP;AAMD,GAhCM,EAgCJ;AACDzB,IAAAA,WAAW,EAAEkB,IADZ;AAEDK,IAAAA,IAAI,EAAErC,QAAQ,CAACQ,QAFd;AAGDmC,IAAAA,QAAQ,EAAE,CAAC,CAHV;AAIDJ,IAAAA,YAAY,EAAErB,OAAO,CAACI;AAJrB,GAhCI,CAAP;AAsCD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASoB,eAAT,CAAyBa,UAAzB,EAAqCC,YAArC,EAAmDtC,OAAnD,EAA4D;AAC1DqC,EAAAA,UAAU,GAAGE,yBAAyB,CAACF,UAAD,EAAarC,OAAb,CAAtC;AACAsC,EAAAA,YAAY,GAAGC,yBAAyB,CAACD,YAAD,EAAetC,OAAf,CAAxC,CAF0D,CAEO;;AAEjE,MAAIsC,YAAY,CAACE,MAAb,GAAsBH,UAAU,CAACG,MAArC,EAA6C;AAC3C,WAAO1D,QAAQ,CAACQ,QAAhB;AACD,GANyD,CAMxD;;;AAGF,MAAI+C,UAAU,KAAKC,YAAnB,EAAiC;AAC/B,WAAOxD,QAAQ,CAACC,oBAAhB;AACD,GAXyD,CAWxD;;;AAGFsD,EAAAA,UAAU,GAAGA,UAAU,CAACI,WAAX,EAAb;AACAH,EAAAA,YAAY,GAAGA,YAAY,CAACG,WAAb,EAAf,CAf0D,CAef;;AAE3C,MAAIJ,UAAU,KAAKC,YAAnB,EAAiC;AAC/B,WAAOxD,QAAQ,CAACE,KAAhB;AACD,GAnByD,CAmBxD;;;AAGF,MAAIqD,UAAU,CAACK,UAAX,CAAsBJ,YAAtB,CAAJ,EAAyC;AACvC,WAAOxD,QAAQ,CAACG,WAAhB;AACD,GAxByD,CAwBxD;;;AAGF,MAAIoD,UAAU,CAACM,QAAX,CAAoB,MAAML,YAA1B,CAAJ,EAA6C;AAC3C,WAAOxD,QAAQ,CAACI,gBAAhB;AACD,GA7ByD,CA6BxD;;;AAGF,MAAImD,UAAU,CAACM,QAAX,CAAoBL,YAApB,CAAJ,EAAuC;AACrC,WAAOxD,QAAQ,CAACK,QAAhB;AACD,GAFD,MAEO,IAAImD,YAAY,CAACE,MAAb,KAAwB,CAA5B,EAA+B;AACpC;AACA;AACA;AACA,WAAO1D,QAAQ,CAACQ,QAAhB;AACD,GAvCyD,CAuCxD;;;AAGF,MAAIsD,UAAU,CAACP,UAAD,CAAV,CAAuBM,QAAvB,CAAgCL,YAAhC,CAAJ,EAAmD;AACjD,WAAOxD,QAAQ,CAACM,OAAhB;AACD,GA5CyD,CA4CxD;AACF;;;AAGA,SAAOyD,mBAAmB,CAACR,UAAD,EAAaC,YAAb,CAA1B;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASM,UAAT,CAAoBE,MAApB,EAA4B;AAC1B,MAAIC,OAAO,GAAG,EAAd;AACA,MAAIC,aAAa,GAAGF,MAAM,CAACG,KAAP,CAAa,GAAb,CAApB;AACAD,EAAAA,aAAa,CAACE,OAAd,CAAsB,UAAUC,YAAV,EAAwB;AAC5C,QAAIC,kBAAkB,GAAGD,YAAY,CAACF,KAAb,CAAmB,GAAnB,CAAzB;AACAG,IAAAA,kBAAkB,CAACF,OAAnB,CAA2B,UAAUG,iBAAV,EAA6B;AACtDN,MAAAA,OAAO,IAAIM,iBAAiB,CAACC,MAAlB,CAAyB,CAAzB,EAA4B,CAA5B,CAAX;AACD,KAFD;AAGD,GALD;AAMA,SAAOP,OAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASF,mBAAT,CAA6BR,UAA7B,EAAyCC,YAAzC,EAAuD;AACrD,MAAIiB,wBAAwB,GAAG,CAA/B;AACA,MAAIC,UAAU,GAAG,CAAjB;;AAEA,WAASC,qBAAT,CAA+BC,SAA/B,EAA0CZ,MAA1C,EAAkD9B,KAAlD,EAAyD;AACvD,SAAK,IAAI2C,CAAC,GAAG3C,KAAR,EAAe4C,CAAC,GAAGd,MAAM,CAACN,MAA/B,EAAuCmB,CAAC,GAAGC,CAA3C,EAA8CD,CAAC,EAA/C,EAAmD;AACjD,UAAIE,UAAU,GAAGf,MAAM,CAACa,CAAD,CAAvB;;AAEA,UAAIE,UAAU,KAAKH,SAAnB,EAA8B;AAC5BH,QAAAA,wBAAwB,IAAI,CAA5B;AACA,eAAOI,CAAC,GAAG,CAAX;AACD;AACF;;AAED,WAAO,CAAC,CAAR;AACD;;AAED,WAASG,UAAT,CAAoBC,MAApB,EAA4B;AAC1B,QAAIC,iBAAiB,GAAGT,wBAAwB,GAAGjB,YAAY,CAACE,MAAhE;AACA,QAAIyB,OAAO,GAAGnF,QAAQ,CAACO,OAAT,GAAmB2E,iBAAiB,IAAI,IAAID,MAAR,CAAlD;AACA,WAAOE,OAAP;AACD;;AAED,MAAIC,UAAU,GAAGT,qBAAqB,CAACnB,YAAY,CAAC,CAAD,CAAb,EAAkBD,UAAlB,EAA8B,CAA9B,CAAtC;;AAEA,MAAI6B,UAAU,GAAG,CAAjB,EAAoB;AAClB,WAAOpF,QAAQ,CAACQ,QAAhB;AACD;;AAEDkE,EAAAA,UAAU,GAAGU,UAAb;;AAEA,OAAK,IAAIpC,CAAC,GAAG,CAAR,EAAWqC,CAAC,GAAG7B,YAAY,CAACE,MAAjC,EAAyCV,CAAC,GAAGqC,CAA7C,EAAgDrC,CAAC,EAAjD,EAAqD;AACnD,QAAI4B,SAAS,GAAGpB,YAAY,CAACR,CAAD,CAA5B;AACA0B,IAAAA,UAAU,GAAGC,qBAAqB,CAACC,SAAD,EAAYrB,UAAZ,EAAwBmB,UAAxB,CAAlC;AACA,QAAIY,KAAK,GAAGZ,UAAU,GAAG,CAAC,CAA1B;;AAEA,QAAI,CAACY,KAAL,EAAY;AACV,aAAOtF,QAAQ,CAACQ,QAAhB;AACD;AACF;;AAED,MAAIyE,MAAM,GAAGP,UAAU,GAAGU,UAA1B;AACA,SAAOJ,UAAU,CAACC,MAAD,CAAjB;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASpD,gBAAT,CAA0BlB,CAA1B,EAA6BC,CAA7B,EAAgCY,QAAhC,EAA0C;AACxC,MAAI+D,MAAM,GAAG,CAAC,CAAd;AACA,MAAIC,MAAM,GAAG,CAAb;AACA,MAAIC,KAAK,GAAG9E,CAAC,CAAC0B,IAAd;AAAA,MACIqD,SAAS,GAAG/E,CAAC,CAACgC,QADlB;AAEA,MAAIgD,KAAK,GAAG/E,CAAC,CAACyB,IAAd;AAAA,MACIuD,SAAS,GAAGhF,CAAC,CAAC+B,QADlB;;AAGA,MAAI8C,KAAK,KAAKE,KAAd,EAAqB;AACnB,QAAID,SAAS,KAAKE,SAAlB,EAA6B;AAC3B;AACA,aAAOpE,QAAQ,CAACb,CAAD,EAAIC,CAAJ,CAAf;AACD,KAHD,MAGO;AACL,aAAO8E,SAAS,GAAGE,SAAZ,GAAwBL,MAAxB,GAAiCC,MAAxC;AACD;AACF,GAPD,MAOO;AACL,WAAOC,KAAK,GAAGE,KAAR,GAAgBJ,MAAhB,GAAyBC,MAAhC;AACD;AACF;AACD;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAAS/B,yBAAT,CAAmCxC,KAAnC,EAA0C4E,KAA1C,EAAiD;AAC/C,MAAIC,cAAc,GAAGD,KAAK,CAACC,cAA3B,CAD+C,CAE/C;AACA;;AACA7E,EAAAA,KAAK,GAAG,KAAKA,KAAb,CAJ+C,CAI3B;;AAEpB,MAAI,CAAC6E,cAAL,EAAqB;AACnB7E,IAAAA,KAAK,GAAGlB,aAAa,CAACkB,KAAD,CAArB;AACD;;AAED,SAAOA,KAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAAS8E,aAAT,CAAuB/D,IAAvB,EAA6BgE,GAA7B,EAAkC;AAChC,MAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC3BA,IAAAA,GAAG,GAAGA,GAAG,CAACA,GAAV;AACD;;AAED,MAAI/E,KAAJ;;AAEA,MAAI,OAAO+E,GAAP,KAAe,UAAnB,EAA+B;AAC7B/E,IAAAA,KAAK,GAAG+E,GAAG,CAAChE,IAAD,CAAX;AACD,GAFD,MAEO,IAAIA,IAAI,IAAI,IAAZ,EAAkB;AACvBf,IAAAA,KAAK,GAAG,IAAR;AACD,GAFM,MAEA,IAAIgF,MAAM,CAACC,cAAP,CAAsBC,IAAtB,CAA2BnE,IAA3B,EAAiCgE,GAAjC,CAAJ,EAA2C;AAChD/E,IAAAA,KAAK,GAAGe,IAAI,CAACgE,GAAD,CAAZ;AACD,GAFM,MAEA,IAAIA,GAAG,CAACnC,QAAJ,CAAa,GAAb,CAAJ,EAAuB;AAC5B;AACA,WAAOuC,eAAe,CAACJ,GAAD,EAAMhE,IAAN,CAAtB;AACD,GAHM,MAGA;AACLf,IAAAA,KAAK,GAAG,IAAR;AACD,GAlB+B,CAkB9B;;;AAGF,MAAIA,KAAK,IAAI,IAAb,EAAmB;AACjB,WAAO,EAAP;AACD;;AAED,MAAIoF,KAAK,CAACC,OAAN,CAAcrF,KAAd,CAAJ,EAA0B;AACxB,WAAOA,KAAP;AACD;;AAED,SAAO,CAACJ,MAAM,CAACI,KAAD,CAAP,CAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASmF,eAAT,CAAyBG,IAAzB,EAA+BvE,IAA/B,EAAqC;AACnC,MAAIZ,IAAI,GAAGmF,IAAI,CAACpC,KAAL,CAAW,GAAX,CAAX;AACA,MAAIqC,MAAM,GAAG,CAACxE,IAAD,CAAb;;AAEA,OAAK,IAAIgB,CAAC,GAAG,CAAR,EAAWqC,CAAC,GAAGjE,IAAI,CAACsC,MAAzB,EAAiCV,CAAC,GAAGqC,CAArC,EAAwCrC,CAAC,EAAzC,EAA6C;AAC3C,QAAIyD,SAAS,GAAGrF,IAAI,CAAC4B,CAAD,CAApB;AACA,QAAI0D,YAAY,GAAG,EAAnB;;AAEA,SAAK,IAAI7B,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG0B,MAAM,CAAC9C,MAA3B,EAAmCmB,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C,UAAI8B,UAAU,GAAGH,MAAM,CAAC3B,CAAD,CAAvB;AACA,UAAI8B,UAAU,IAAI,IAAlB,EAAwB;;AAExB,UAAIV,MAAM,CAACC,cAAP,CAAsBC,IAAtB,CAA2BQ,UAA3B,EAAuCF,SAAvC,CAAJ,EAAuD;AACrD,YAAIG,WAAW,GAAGD,UAAU,CAACF,SAAD,CAA5B;;AAEA,YAAIG,WAAW,IAAI,IAAnB,EAAyB;AACvBF,UAAAA,YAAY,CAAClE,IAAb,CAAkBoE,WAAlB;AACD;AACF,OAND,MAMO,IAAIH,SAAS,KAAK,GAAlB,EAAuB;AAC5B;AACAC,QAAAA,YAAY,GAAGA,YAAY,CAACG,MAAb,CAAoBF,UAApB,CAAf;AACD;AACF;;AAEDH,IAAAA,MAAM,GAAGE,YAAT;AACD;;AAED,MAAIL,KAAK,CAACC,OAAN,CAAcE,MAAM,CAAC,CAAD,CAApB,CAAJ,EAA8B;AAC5B;AACA;AACA,QAAIM,MAAM,GAAG,EAAb;AACA,WAAOA,MAAM,CAACD,MAAP,CAAcE,KAAd,CAAoBD,MAApB,EAA4BN,MAA5B,CAAP;AACD,GAhCkC,CAgCjC;AACF;;;AAGA,SAAOA,MAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAAS3D,kBAAT,CAA4Bb,IAA5B,EAAkCZ,IAAlC,EAAwC;AACtC,MAAI4F,SAAS,GAAG,EAAhB;;AAEA,OAAK,IAAInC,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG1D,IAAI,CAACsC,MAAzB,EAAiCmB,CAAC,GAAGC,CAArC,EAAwCD,CAAC,EAAzC,EAA6C;AAC3C,QAAImB,GAAG,GAAG5E,IAAI,CAACyD,CAAD,CAAd;AACA,QAAI3B,UAAU,GAAG+D,gBAAgB,CAACjB,GAAD,CAAjC;AACA,QAAIkB,UAAU,GAAGnB,aAAa,CAAC/D,IAAD,EAAOgE,GAAP,CAA9B;;AAEA,SAAK,IAAIhD,CAAC,GAAG,CAAR,EAAWqC,CAAC,GAAG6B,UAAU,CAACxD,MAA/B,EAAuCV,CAAC,GAAGqC,CAA3C,EAA8CrC,CAAC,EAA/C,EAAmD;AACjDgE,MAAAA,SAAS,CAACxE,IAAV,CAAe;AACbS,QAAAA,SAAS,EAAEiE,UAAU,CAAClE,CAAD,CADR;AAEbE,QAAAA,UAAU,EAAEA;AAFC,OAAf;AAID;AACF;;AAED,SAAO8D,SAAP;AACD;;AAED,IAAIG,oBAAoB,GAAG;AACzB7D,EAAAA,UAAU,EAAE8D,QADa;AAEzB/D,EAAAA,UAAU,EAAE,CAAC+D;AAFY,CAA3B;AAIA;AACA;AACA;AACA;AACA;;AAEA,SAASH,gBAAT,CAA0BjB,GAA1B,EAA+B;AAC7B,MAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC3B,WAAOmB,oBAAP;AACD;;AAED,SAAOrH,QAAQ,CAAC,EAAD,EAAKqH,oBAAL,EAA2BnB,GAA3B,CAAf;AACD;AACD;AACA;AACA;AACA;;;AAEA,SAAStF,iBAAT,EAA4BD,WAA5B,EAAyCT,QAAzC","sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport removeAccents from 'remove-accents';\n\nvar rankings = {\n  CASE_SENSITIVE_EQUAL: 7,\n  EQUAL: 6,\n  STARTS_WITH: 5,\n  WORD_STARTS_WITH: 4,\n  CONTAINS: 3,\n  ACRONYM: 2,\n  MATCHES: 1,\n  NO_MATCH: 0\n};\nmatchSorter.rankings = rankings;\n\nvar defaultBaseSortFn = function (a, b) {\n  return String(a.rankedValue).localeCompare(String(b.rankedValue));\n};\n/**\n * Takes an array of items and a value and returns a new array with the items that match the given value\n * @param {Array} items - the items to sort\n * @param {String} value - the value to use for ranking\n * @param {Object} options - Some options to configure the sorter\n * @return {Array} - the new sorted array\n */\n\n\nfunction matchSorter(items, value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      keys = _options.keys,\n      _options$threshold = _options.threshold,\n      threshold = _options$threshold === void 0 ? rankings.MATCHES : _options$threshold,\n      _options$baseSort = _options.baseSort,\n      baseSort = _options$baseSort === void 0 ? defaultBaseSortFn : _options$baseSort;\n  var matchedItems = items.reduce(reduceItemsToRanked, []);\n  return matchedItems.sort(function (a, b) {\n    return sortRankedValues(a, b, baseSort);\n  }).map(function (_ref) {\n    var item = _ref.item;\n    return item;\n  });\n\n  function reduceItemsToRanked(matches, item, index) {\n    var rankingInfo = getHighestRanking(item, keys, value, options);\n    var rank = rankingInfo.rank,\n        _rankingInfo$keyThres = rankingInfo.keyThreshold,\n        keyThreshold = _rankingInfo$keyThres === void 0 ? threshold : _rankingInfo$keyThres;\n\n    if (rank >= keyThreshold) {\n      matches.push(_extends({}, rankingInfo, {\n        item: item,\n        index: index\n      }));\n    }\n\n    return matches;\n  }\n}\n/**\n * Gets the highest ranking for value for the given item based on its values for the given keys\n * @param {*} item - the item to rank\n * @param {Array} keys - the keys to get values from the item for the ranking\n * @param {String} value - the value to rank against\n * @param {Object} options - options to control the ranking\n * @return {{rank: Number, keyIndex: Number, keyThreshold: Number}} - the highest ranking\n */\n\n\nfunction getHighestRanking(item, keys, value, options) {\n  if (!keys) {\n    // if keys is not specified, then we assume the item given is ready to be matched\n    var stringItem = item;\n    return {\n      // ends up being duplicate of 'item' in matches but consistent\n      rankedValue: stringItem,\n      rank: getMatchRanking(stringItem, value, options),\n      keyIndex: -1,\n      keyThreshold: options.threshold\n    };\n  }\n\n  var valuesToRank = getAllValuesToRank(item, keys);\n  return valuesToRank.reduce(function (_ref2, _ref3, i) {\n    var rank = _ref2.rank,\n        rankedValue = _ref2.rankedValue,\n        keyIndex = _ref2.keyIndex,\n        keyThreshold = _ref2.keyThreshold;\n    var itemValue = _ref3.itemValue,\n        attributes = _ref3.attributes;\n    var newRank = getMatchRanking(itemValue, value, options);\n    var newRankedValue = rankedValue;\n    var minRanking = attributes.minRanking,\n        maxRanking = attributes.maxRanking,\n        threshold = attributes.threshold;\n\n    if (newRank < minRanking && newRank >= rankings.MATCHES) {\n      newRank = minRanking;\n    } else if (newRank > maxRanking) {\n      newRank = maxRanking;\n    }\n\n    if (newRank > rank) {\n      rank = newRank;\n      keyIndex = i;\n      keyThreshold = threshold;\n      newRankedValue = itemValue;\n    }\n\n    return {\n      rankedValue: newRankedValue,\n      rank: rank,\n      keyIndex: keyIndex,\n      keyThreshold: keyThreshold\n    };\n  }, {\n    rankedValue: item,\n    rank: rankings.NO_MATCH,\n    keyIndex: -1,\n    keyThreshold: options.threshold\n  });\n}\n/**\n * Gives a rankings score based on how well the two strings match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @param {Object} options - options for the match (like keepDiacritics for comparison)\n * @returns {Number} the ranking for how well stringToRank matches testString\n */\n\n\nfunction getMatchRanking(testString, stringToRank, options) {\n  testString = prepareValueForComparison(testString, options);\n  stringToRank = prepareValueForComparison(stringToRank, options); // too long\n\n  if (stringToRank.length > testString.length) {\n    return rankings.NO_MATCH;\n  } // case sensitive equals\n\n\n  if (testString === stringToRank) {\n    return rankings.CASE_SENSITIVE_EQUAL;\n  } // Lower casing before further comparison\n\n\n  testString = testString.toLowerCase();\n  stringToRank = stringToRank.toLowerCase(); // case insensitive equals\n\n  if (testString === stringToRank) {\n    return rankings.EQUAL;\n  } // starts with\n\n\n  if (testString.startsWith(stringToRank)) {\n    return rankings.STARTS_WITH;\n  } // word starts with\n\n\n  if (testString.includes(\" \" + stringToRank)) {\n    return rankings.WORD_STARTS_WITH;\n  } // contains\n\n\n  if (testString.includes(stringToRank)) {\n    return rankings.CONTAINS;\n  } else if (stringToRank.length === 1) {\n    // If the only character in the given stringToRank\n    //   isn't even contained in the testString, then\n    //   it's definitely not a match.\n    return rankings.NO_MATCH;\n  } // acronym\n\n\n  if (getAcronym(testString).includes(stringToRank)) {\n    return rankings.ACRONYM;\n  } // will return a number between rankings.MATCHES and\n  // rankings.MATCHES + 1 depending  on how close of a match it is.\n\n\n  return getClosenessRanking(testString, stringToRank);\n}\n/**\n * Generates an acronym for a string.\n *\n * @param {String} string the string for which to produce the acronym\n * @returns {String} the acronym\n */\n\n\nfunction getAcronym(string) {\n  var acronym = '';\n  var wordsInString = string.split(' ');\n  wordsInString.forEach(function (wordInString) {\n    var splitByHyphenWords = wordInString.split('-');\n    splitByHyphenWords.forEach(function (splitByHyphenWord) {\n      acronym += splitByHyphenWord.substr(0, 1);\n    });\n  });\n  return acronym;\n}\n/**\n * Returns a score based on how spread apart the\n * characters from the stringToRank are within the testString.\n * A number close to rankings.MATCHES represents a loose match. A number close\n * to rankings.MATCHES + 1 represents a tighter match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @returns {Number} the number between rankings.MATCHES and\n * rankings.MATCHES + 1 for how well stringToRank matches testString\n */\n\n\nfunction getClosenessRanking(testString, stringToRank) {\n  var matchingInOrderCharCount = 0;\n  var charNumber = 0;\n\n  function findMatchingCharacter(matchChar, string, index) {\n    for (var j = index, J = string.length; j < J; j++) {\n      var stringChar = string[j];\n\n      if (stringChar === matchChar) {\n        matchingInOrderCharCount += 1;\n        return j + 1;\n      }\n    }\n\n    return -1;\n  }\n\n  function getRanking(spread) {\n    var inOrderPercentage = matchingInOrderCharCount / stringToRank.length;\n    var ranking = rankings.MATCHES + inOrderPercentage * (1 / spread);\n    return ranking;\n  }\n\n  var firstIndex = findMatchingCharacter(stringToRank[0], testString, 0);\n\n  if (firstIndex < 0) {\n    return rankings.NO_MATCH;\n  }\n\n  charNumber = firstIndex;\n\n  for (var i = 1, I = stringToRank.length; i < I; i++) {\n    var matchChar = stringToRank[i];\n    charNumber = findMatchingCharacter(matchChar, testString, charNumber);\n    var found = charNumber > -1;\n\n    if (!found) {\n      return rankings.NO_MATCH;\n    }\n  }\n\n  var spread = charNumber - firstIndex;\n  return getRanking(spread);\n}\n/**\n * Sorts items that have a rank, index, and keyIndex\n * @param {Object} a - the first item to sort\n * @param {Object} b - the second item to sort\n * @return {Number} -1 if a should come first, 1 if b should come first, 0 if equal\n */\n\n\nfunction sortRankedValues(a, b, baseSort) {\n  var aFirst = -1;\n  var bFirst = 1;\n  var aRank = a.rank,\n      aKeyIndex = a.keyIndex;\n  var bRank = b.rank,\n      bKeyIndex = b.keyIndex;\n\n  if (aRank === bRank) {\n    if (aKeyIndex === bKeyIndex) {\n      // use the base sort function as a tie-breaker\n      return baseSort(a, b);\n    } else {\n      return aKeyIndex < bKeyIndex ? aFirst : bFirst;\n    }\n  } else {\n    return aRank > bRank ? aFirst : bFirst;\n  }\n}\n/**\n * Prepares value for comparison by stringifying it, removing diacritics (if specified)\n * @param {String} value - the value to clean\n * @param {Object} options - {keepDiacritics: whether to remove diacritics}\n * @return {String} the prepared value\n */\n\n\nfunction prepareValueForComparison(value, _ref4) {\n  var keepDiacritics = _ref4.keepDiacritics;\n  // value might not actually be a string at this point (we don't get to choose)\n  // so part of preparing the value for comparison is ensure that it is a string\n  value = \"\" + value; // toString\n\n  if (!keepDiacritics) {\n    value = removeAccents(value);\n  }\n\n  return value;\n}\n/**\n * Gets value for key in item at arbitrarily nested keypath\n * @param {Object} item - the item\n * @param {Object|Function} key - the potentially nested keypath or property callback\n * @return {Array} - an array containing the value(s) at the nested keypath\n */\n\n\nfunction getItemValues(item, key) {\n  if (typeof key === 'object') {\n    key = key.key;\n  }\n\n  var value;\n\n  if (typeof key === 'function') {\n    value = key(item);\n  } else if (item == null) {\n    value = null;\n  } else if (Object.hasOwnProperty.call(item, key)) {\n    value = item[key];\n  } else if (key.includes('.')) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    return getNestedValues(key, item);\n  } else {\n    value = null;\n  } // because `value` can also be undefined\n\n\n  if (value == null) {\n    return [];\n  }\n\n  if (Array.isArray(value)) {\n    return value;\n  }\n\n  return [String(value)];\n}\n/**\n * Given path: \"foo.bar.baz\"\n * And item: {foo: {bar: {baz: 'buzz'}}}\n *   -> 'buzz'\n * @param path a dot-separated set of keys\n * @param item the item to get the value from\n */\n\n\nfunction getNestedValues(path, item) {\n  var keys = path.split('.');\n  var values = [item];\n\n  for (var i = 0, I = keys.length; i < I; i++) {\n    var nestedKey = keys[i];\n    var nestedValues = [];\n\n    for (var j = 0, J = values.length; j < J; j++) {\n      var nestedItem = values[j];\n      if (nestedItem == null) continue;\n\n      if (Object.hasOwnProperty.call(nestedItem, nestedKey)) {\n        var nestedValue = nestedItem[nestedKey];\n\n        if (nestedValue != null) {\n          nestedValues.push(nestedValue);\n        }\n      } else if (nestedKey === '*') {\n        // ensure that values is an array\n        nestedValues = nestedValues.concat(nestedItem);\n      }\n    }\n\n    values = nestedValues;\n  }\n\n  if (Array.isArray(values[0])) {\n    // keep allowing the implicit wildcard for an array of strings at the end of\n    // the path; don't use `.flat()` because that's not available in node.js v10\n    var result = [];\n    return result.concat.apply(result, values);\n  } // Based on our logic it should be an array of strings by now...\n  // assuming the user's path terminated in strings\n\n\n  return values;\n}\n/**\n * Gets all the values for the given keys in the given item and returns an array of those values\n * @param item - the item from which the values will be retrieved\n * @param keys - the keys to use to retrieve the values\n * @return objects with {itemValue, attributes}\n */\n\n\nfunction getAllValuesToRank(item, keys) {\n  var allValues = [];\n\n  for (var j = 0, J = keys.length; j < J; j++) {\n    var key = keys[j];\n    var attributes = getKeyAttributes(key);\n    var itemValues = getItemValues(item, key);\n\n    for (var i = 0, I = itemValues.length; i < I; i++) {\n      allValues.push({\n        itemValue: itemValues[i],\n        attributes: attributes\n      });\n    }\n  }\n\n  return allValues;\n}\n\nvar defaultKeyAttributes = {\n  maxRanking: Infinity,\n  minRanking: -Infinity\n};\n/**\n * Gets all the attributes for the given key\n * @param key - the key from which the attributes will be retrieved\n * @return object containing the key's attributes\n */\n\nfunction getKeyAttributes(key) {\n  if (typeof key === 'string') {\n    return defaultKeyAttributes;\n  }\n\n  return _extends({}, defaultKeyAttributes, key);\n}\n/*\neslint\n  no-continue: \"off\",\n*/\n\nexport { defaultBaseSortFn, matchSorter, rankings };\n"]},"metadata":{},"sourceType":"module"}